-- *** JOIN
--하나 이상의 테이블에서 데이터를 조회하기 위해 사용
--수행결과는 하나의 RESULT SET 으로 나온다.
--관계형 데이터베이스에서는 데이터의 중복을 최소화 하기 위해 최소한의 데이터를
--테이블 저장해두고, 필요할 때 테이블간 관계를 통해 데이터를 조합해서 추출한다.

--직원번호, 직원명, 부서코드, 부서명을 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE E JOIN DEPARTMENT D
ON(E.DEPT_CODE = D.DEPT_ID);

-- 0.CROSS JOIN(안씀)
-- Cartesan 곱이 발생하기 때문에 사용하지 않는다.
-- 한 쪽 테이블의 모든 행과 다른 테이블의 모든 행을 JOIN
-- EMPLOYEE 테이블의 ROW수 * DEPARTMENT 테이블의 ROW수 만큼의 ROW를 생성
-- 3만개 상품데이터와 5만개의 주문데이터를 CROSS JOIN 하면 15억개의 ROW가 반환
SELECT *
FROM EMPLOYEE CROSS JOIN DEPARTMENT
ORDER BY EMP_ID DESC, DEPT_ID ASC;

--JOIN의 종류
-- CROSS JOIN, INNER JOIN, OUTER JOIN(LEFT JOIN, RIGHT JOIN)
-- 1. INNER JOIN (등가 조인 (EQUALS JOIN))
-- JOIN 조건문을 작성하여 조건문에 부합하는 ROW들만 JOIN을 수행
-- ON() 안에 JOIN 조건절을 작성
-- 만약에 조건절에서 사용할 두 테이블의 컬럼명이 같다면 USING(컬럼명)형식으로도 가능
SELECT *
FROM EMPLOYEE E 
INNER JOIN JOB J 
ON(E.JOB_CODE = J.JOB_CODE);

--ANSI 표준구문
--ANSI(미국 국립 표준 협회)에서 제정한 표준 구문
--ON 사용
SELECT EMP_ID, EMP_NAME,E.JOB_CODE, J.JOB_CODE, JOB_NAME
FROM EMPLOYEE E 
INNER JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE);

--USING 사용
SELECT EMP_ID, EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE JOIN JOB USING(JOB_CODE);

--여러 테이블 JOIN 해보기
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE E 
INNER JOIN DEPARTMENT D ON(E.DEPT_CODE = D.DEPT_ID)
INNER JOIN LOCATION L ON(D.LOCATION_ID = L.LOCAL_CODE);

--ORACLE 구문
--JOIN할 테이블을 ,으로 연결하고
--JOIN 조건절을 WHERE 절에 작성
SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JFROOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE;

--여러 테이블 JOIN
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE E, DEPARTMENT D, LOCATION L
WHERE
E.DEPT_CODE = D.DEPT_ID
AND D.LOCATION_ID = L.LOCAL_CODE;

--부서 테이블에서 부서별 지역명을 조회하세요
--ANSI
SELECT DEPT_TITLE, LOCAL_NAME
FROM DEPARTMENT
INNER JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);
--ORACLE
SELECT DEPT_TITLE, LOCAL_NAME
FROM DEPARTMENT, LOCATION
WHERE LOCATION_ID = LOCAL_CODE;
--------------------------------------------------------
-- *** OUTER JOIN
-- JOIN 조건절과 일치하지 않는 ROW도 JOIN에 포함 시킨다.
-- LEFT [OUTER] JOIN, RIGHT [OUTER] JOIN, FULL OUTER JOIN

--OUTER JOIN과 비교할 INNER JOIN 쿼리문 작성
SELECT EMP_NAME, DEPT_TITLE, DEPT_CODE
FROM EMPLOYEE 
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);
--새로운 직급 입력
INSERT INTO JOB(JOB_CODE, JOB_NAME) VALUES('J8','인턴');
COMMIT;
SELECT * FROM JOB;

--1) LEFT [OUTER] JOIN : FROM절에서 LEFT JOIN 구문 왼편 테이블을 기준으로 JOIN 발생
SELECT *
FROM JOB LEFT JOIN EMPLOYEE USING(JOB_CODE) ORDER BY JOB_CODE;
--2) RIGHT [OUTER] JOIN : FROM절에서 RIGHT JOIN 구문 오른편 테이블을 기준으로 JOIN 발생
SELECT * 
FROM EMPLOYEE RIGHT JOIN JOB USING(JOB_CODE) ORDER BY JOB_CODE;
--ORACLE
--JOIN 조건절에서 JOIN이 기준이 되지 않는 테이블의 컬럼에 (+) 를 표시
SELECT *
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE(+) = J.JOB_CODE;
--3. FULL OUTER JOIN : 조인 조건절에 일치하지 않는 ROW를 양 테이블 모두 결과에 포함시킴
SELECT EMP_NAME, DEPT_TITLE, DEPT_ID
FROM EMPLOYEE 
FULL OUTER JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

--4. 비등가 조인(NON EQUAL JOIN)
-- 조인 조건절에 '=' 대신 다른 연산자를 사용하는 JOIN문
-- 조건절의 범위에 포함되는 행들을 연결할 때 사용한다.
SELECT 
EMP_NAME, SALARY, E.SAL_LEVEL, S.MIN_SAL, S.MAX_SAL
FROM EMPLOYEE E JOIN SAL_GRADE S
ON(E.SALARY < 2500000 AND S.MAX_SAL < 2999999);

--5.자체 조인(SELF JOIN)
-- 자기 자신과 JOIN
-- EMPLOYEE 테이블에서 사원의 이름, 부서코드, 관리자 사번, 관리자 이름을 출력하시오
--SUB QUERY
SELECT EMP_NAME, DEPT_CODE, MANAGER_ID
, (SELECT EMP_NAME FROM EMPLOYEE WHERE EMP_ID = E.MANAGER_ID) 관리자명
FROM EMPLOYEE E;

--SELF JOIN
SELECT E.EMP_NAME, E.DEPT_CODE, E.MANAGER_ID, M.EMP_NAME
FROM EMPLOYEE E JOIN EMPLOYEE M ON(E.MANAGER_ID = M.EMP_ID);







































